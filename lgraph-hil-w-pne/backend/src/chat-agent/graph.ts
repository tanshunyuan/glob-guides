/**@see @link{https://v03.api.js.langchain.com/classes/_langchain_core.output_parsers_openai_tools.JsonOutputToolsParser.html} */
import { JsonOutputToolsParser } from "@langchain/core/output_parsers/openai_tools";
import { ChatPromptTemplate } from "@langchain/core/prompts";
import {
  Annotation,
  Command,
  END,
  interrupt,
  MemorySaver,
  START,
  StateGraph,
} from "@langchain/langgraph";
import { createReactAgent } from "@langchain/langgraph/prebuilt";
import { ChatOpenAI } from "@langchain/openai";
import { TavilySearch } from "@langchain/tavily";
import { env } from "../../../env.js";
import z from "zod";
import { tool } from "@langchain/core/tools";
import { Runnable, RunnableConfig } from "@langchain/core/runnables";
import { HumanMessage } from "@langchain/core/messages";

/** @description state for the entire graph */
const PlanExecuteState = Annotation.Root({
  /** @description input from the user / client */
  input: Annotation<string>({
    reducer: (x, y) => y ?? x ?? "",
  }),
  /** @description the list of plan/outline/steps to take generated by the llm */
  plan: Annotation<string[]>({
    reducer: (x, y) => y ?? x ?? [],
  }),
  /** @description
   * a list of past steps that've been executed
   * [string, string]
   * - first element is the instruction
   * - second element is the result of the instruction
   */
  pastSteps: Annotation<[string, string][]>({
    reducer: (x, y) => x.concat(y),
  }),
  /** @description response from the llm */
  response: Annotation<string>({
    reducer: (x, y) => y ?? x,
  }),
});

type State = typeof PlanExecuteState.State;
type StateResponse = Promise<Partial<State>>;

const webSearchTool = new TavilySearch({
  maxResults: 3,
  tavilyApiKey: env.TAVILY_API_KEY,
});

/**
 * @description
 * a pre-built Reasoning and Acting (ReAct) Agent from langgraph
 * equipped with web searching capabilities through webSearchTool
 */
const agentExecutor = createReactAgent({
  llm: new ChatOpenAI({
    model: "gpt-4o-mini",
  }),
  tools: [webSearchTool],
});

/**
 * @description
 * ChatPromptTemplate convience fn to write a prompt, helps with validation and string interpolation.
 */
const plannerPrompt = ChatPromptTemplate.fromTemplate(`
For the given objective, come up with a simple step by step plan. \
This plan should involve individual tasks, that if executed correctly will yield the correct answer. Do not add any superfluous steps. \
The result of the final step should be the final answer. Make sure that each step has all the information needed - do not skip steps.

{objective}
  `);

/**@description schema to guide the llm to return a structured output */
const planObject = z.object({
  steps: z
    .array(z.string())
    .describe("different steps to follow, should be in sorted order"),
});

/** @description llm doesn't have any tools */
const plannerModel = new ChatOpenAI({
  model: "gpt-4-0125-preview",
}).withStructuredOutput(planObject);

/** @description
 * comes up with an INITIAL plan for the agent to perform a search
 */
const planner = plannerPrompt.pipe(plannerModel);

const responseObject = z.object({
  response: z.string().describe("Response to user."),
});

/**@description tool will not be invoked, instead it serves as a contract / guides the llm to output the response in a certain format */
const responseTool = tool(() => { }, {
  name: "response",
  description: "Respond to the user.",
  schema: responseObject,
});

/**@description tool will not be invoked, instead it serves as a contract / guides the llm to output the plan in a certain format */
const planTool = tool(() => { }, {
  name: "plan",
  description: "This tool is used to plan the steps to follow.",
  schema: planObject,
});

const replannerPrompt = ChatPromptTemplate.fromTemplate(`
For the given objective, come up with a simple step by step plan.
This plan should involve individual tasks, that if executed correctly will yield the correct answer. Do not add any superfluous steps.
The result of the final step should be the final answer. Make sure that each step has all the information needed - do not skip steps.

Your objective was this:
{input}

Your original plan was this:
{plan}

You have currently done the follow steps:
{pastSteps}

Update your plan accordingly. If no more steps are needed and you can return to the user, then respond with that and use the 'response' function.
Otherwise, fill out the plan.
Only add steps to the plan that still NEED to be done. Do not return previously done steps as part of the plan.
  `);

const parser = new JsonOutputToolsParser();

/**@description llm with tools */
const replannerModel = new ChatOpenAI({
  model: "gpt-4o",
}).bindTools([planTool, responseTool]);

/**
 * @description
 * updates the generated plan with the latest information found through the agentExecutor
 */
const replanner = replannerPrompt.pipe(replannerModel).pipe(parser);

/**
 * @description invoking the planner llm to create the initial plan
 * @param state - passed in when using .addNode
 */
const planStep = async (state: State): StateResponse => {
  console.log(`at planStep`)
  // `objective` will be passed to `plannerPrompt`
  const plan = await planner.invoke({ objective: state.input });
  console.log(`planStep.plan ==> ${JSON.stringify(plan, null, 2)}`)
  // plan.steps is typed from `planObject`
  return { plan: plan.steps };
};

/**
 * @description invoking the agentExecutor to perform a web search with the webSearchTool
 */
const executeStep = async (
  state: State,
  config?: RunnableConfig,
): StateResponse => {
  console.log(`at executeStep`)
  // grab the first step in the plan?
  const task = state.plan[0];

  // mimic human input programatically
  const input = {
    messages: [new HumanMessage(task)],
  };
  const { messages } = await agentExecutor.invoke(input, config);
  const lastMessage = messages[messages.length - 1];
  return {
    pastSteps: [[task, lastMessage.content.toString()]],
    // remove the 'done' step, leaving the remaining plans in the state
    plan: state.plan.slice(1),
  };
};

const replanStep = async (state: State): StateResponse => {
  console.log(`at replanStep`)
  // the parameters in replanner.invoke is defined in `replannerPrompt`
  const output = await replanner.invoke({
    input: state.input,
    plan: state.plan.join("\n"),
    pastSteps: state.pastSteps
      .map(([step, result]) => `${step}: ${result}`)
      .join("\n"),
  });

  // Format of this is determined with `parser` aka the JsonOutputToolsParser,
  // but I've no idea which method of `parser` that's called
  const toolCall = output[0] as {
    type: string;
    args?: {
      response: string;
      steps: string[];
    };
  };

  console.log(`replanStep.toolCall ==> ${JSON.stringify(toolCall, null, 2)}`)

  if (toolCall.type === "response") {
    return { response: toolCall.args?.response };
  }
  return { plan: toolCall.args?.steps };
};

/**@description node to determine to end the agent execution or re-route the call to the executeStep */
const shouldEnd = (state: State) => {
  return state.response ? "end" : "continue";
};

const humanReviewStep = (state: State): Command => {
  console.log(`at humanReviewStep`)
  console.log(`humanReviewStep.state.plan ==> ${JSON.stringify(state.plan, null, 2)}`)
  const result = interrupt<
    {
      question: string;
      plan: State["plan"];
    },
    {
      action: {
        type: "accept" | "feedback";
        feedback?: string;
      };
    }
  >({
    question: "Is the plan ok? (accept / feedback)",
    plan: state.plan,
  });

  const { action } = result;

  switch (action.type) {
    case "accept": {
      return new Command({
        goto: "agent",
      });
    }
    case "feedback": {
      const finalFeedback = `
      For the given plan:
      ${state.plan}

      Here's the feedback from the user:
      ${action.feedback}

      Revise or update the plan accordingly.
      `
      console.log(`humanReviewStep.feedback.finalFeedback ==> ${JSON.stringify(finalFeedback, null, 2)}`)
      return new Command({
        goto: "planner",
        update: {
          input: finalFeedback,
          plan: [],
        },
      });
    }
    default: {
      throw new Error("Invalid action");
    }
  }
};

const chatAgentWorkflow = new StateGraph(PlanExecuteState)
  .addNode("planner", planStep)
  .addNode("human_review", humanReviewStep, {
    ends: ["planner", "agent"],
  })
  .addNode("agent", executeStep)
  .addNode("replan", replanStep)
  .addEdge(START, "planner")
  .addEdge("planner", "human_review")
  .addEdge("agent", "replan")
  .addConditionalEdges("replan", shouldEnd, {
    continue: "agent", // go back to the agent to find stuff
    end: END, // end it!
  });

const checkpointer = new MemorySaver();
export const chatAgent = chatAgentWorkflow.compile({
  checkpointer,
});
